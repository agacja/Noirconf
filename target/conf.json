{
  "noir_version": "0.25.0+3f676051a6073d6eabdc7fee68e4b522334344f6",
  "hash": 14575326877045194263,
  "abi": {
    "parameters": [
      {
        "name": "sins",
        "type": { "kind": "array", "length": 7, "type": { "kind": "field" } },
        "visibility": "private"
      }
    ],
    "param_witnesses": { "sins": [{ "start": 0, "end": 7 }] },
    "return_type": null,
    "return_witnesses": []
  },
  "bytecode": "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",
  "debug_symbols": "1dzdThtHGIDhe/Exqub7nRlupeoBTVMpUkSihFaqotx7jZvd/OyYlV8iOj4DsQ98a17Pmlng0+Htu1d3D2/e3X883H46lMPtr58OH9/f3T++9/Hh7sPD4TZLuzm8vv/j+JaWzzeHP9+8fX249fr5t5uDjEAt9gVUtW/BzeZQDalfjtUwXQ+WPjpYUpaDpdrTBzf1L8c2/+7Q49Q679Spy9QtfpjarnJqn3bqrsux3fvTh9ZYngK1+3ro8dlwPMGY9wQjlhNsxk8wpz1BKbZ8ZinVfyivXunc7Urn7lc6t5RrHXzeq+/O4PNegEWjL4Nrq3zVlHkv1z/vHH3ic+zLFGIqzzjHea/vP+8cX/gSv46tx5P8cW2oE83yspdiL+vBbvGMb2e/yrH1Za/D7uszzfMZr/9VrnJs+WX4RLO+fHovbeenvrr81NfLd599sFJJy/WK883jsYzS5hmlzzPK+IXp/zSLTDSLTjSLTTSLTzRLTDRLTjTLRKuuTLTsykTrrk607upE665OtO7qROuuTrTu6kTrrk607upE665OtO7qZevuyVgBZriOuS3DudWtUWAMGAcmgBk+HzyXuzSeuTUVmAZMv9z4sAPvZTFdtkaAUWAMGAdm+FhHWTZYQwamX25i+BikLgtBWmyNAQNmy2EHYcvjFl62RoBRYAwYByaASWAqMA2Yfrmpux30rRFgxh3o2mgMzLiD9bkwNA5MADPuYL1wR9etqcA0YPrlphVgxh3UthrbGgXGgHFgApgEpgLTgOmXm16eNlm2HXQB5kwHy656ysCMO8j+lHFgApi8/LrdKzANmH65kVIIEoKUoItfJ+n4NoG4rTdkPX2Dxhv6u0qQUqQMKUcqkEqkKlINKdSGojYUtaGoDUVtKGpDURuK2lDUhqI2FLVhqA1DbdiZNtry69QSsl0OzZBypAKpRKoi1ZDqRHlBSpBCbThqw1Ebjtpw1IajNhy14aiNQG0EaiNQG4HaCNRGoDYCtRGojUBtBGojURuJ2kjUxnh7TKK1VfW6VeNHo9lyd0Ka50aNt4f2vtZ4g2hXBVLjNjLWxzBzoDpR4w2cXSVIKVK2q6pslSMVSCVSFakzbXh+VbpVnahekBKkFClDypEKpBKpitSZNvr6JwBVB9sbnagzGz37TBhTxowxZywYS8bGjdRY/xqnVhuwxlhH7MzW1M4lWs7sTe0yZywYa4yhVy1yZtNolwlj4PsmOd4q1VKWW3xadKDGe6X7TBhTxowxZywYS8YqY40xVomySpRVoqwSZZUoq0RZJcoqUVaJskqUVWKsEmOVGKvEWCXGKjFWibFKjFVirBJjlTirxFklzipxVomfqcS+Mhux/Uq2v+eYZ3crn7rzcGRRGBPGlDFjzBkLxpKxylhjjFWSrJJklSSrJFklySpJVkmySpJVkqySZJVUVklllVSwwf3IjDFnLBhLxipjjbGOWCuMCWOsksYqaaySxipprJLGKmmsksYq6aySzirprJLOKumsks4q6aySzirprJLOKjm3+b3vBDqFDtxXPTmwR3nakTP29c5s3O67gA7cYT25zpwW6AQ6hQ7caz05hy6gS+gqdOCu68l15qxAJ9ApdAadQxfQJXQVOnAn9uQ6c16gE+gUOoPOoQvoEjpwT/bkGnSduWC39yQMOocuoGvQwdc9WaAT6C7+/h3f+fvuw5u739++fvz3348f++v+1fLfwI/vPvzz/r+PfP4X",
  "file_map": {
    "19": {
      "source": "// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n/// A hint for decomposing a single field into two 16 byte fields.\nunconstrained fn decompose_unsafe(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    // Take hints of the decomposition\n    let (xlo, xhi) = decompose_unsafe(x);\n    let borrow = lt_unsafe(PLO, xlo, 16);\n\n    // Range check the limbs\n    xlo.assert_max_bit_size(128);\n    xhi.assert_max_bit_size(128);\n\n    // Check that the decomposition is correct\n    assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n    // Check that (xlo < plo && xhi <= phi) || (xlo >= plo && xhi < phi)\n    let rlo = PLO - xlo + (borrow as Field) * TWO_POW_128;\n    let rhi = PHI - xhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n\n    (xlo, xhi)\n}\n\nunconstrained fn lt_unsafe(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.__to_le_radix(256, num_bytes);\n    let y_bytes = y.__to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nunconstrained fn lte_unsafe(x: Field, y: Field, num_bytes: u32) -> bool {\n    lt_unsafe(x, y, num_bytes) | (x == y)\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    // Decompose a and b\n    let (alo, ahi) = decompose(a);\n    let (blo, bhi) = decompose(b);\n\n    let borrow = lte_unsafe(alo, blo, 16);\n\n    // Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if a == b {\n        false\n    } else if lt_unsafe(a, b, 32) {\n        assert_gt(b, a);\n        false\n    } else {\n        assert_gt(a, b);\n        true\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n",
      "path": "std/field/bn254.nr"
    },
    "20": {
      "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n",
      "path": "std/field.nr"
    },
    "47": {
      "source": "use dep::std::field::bn254::assert_lt;\n\nmod SinType {\n    global LustforEndlessCryptocurrencies: Field = 0;\n    global GluttonyofSmartContracts: Field = 1;\n    global GreedforGasFees: Field = 2; // Third sin related to Gas Fees\n    global SlothinBlockchainSyncing: Field = 3;\n    global WrathAgainstForks: Field = 4;\n    global EnvyofEthereumSuccess: Field = 5;\n    global PrideinDecentralization: Field = 6;\n}\n\nfn main(sins: [Field; 7]) {\n    let mut total = 0;\n    // Corresponding weights for each sin\n    let weights = [5, 1, 10000, 2, 1, 1, 1];\n\n    // Check for the 'Greed for Gas Fees' sin\n    assert(sins[2] == 0);\n\n    for i in 0..sins.len() {\n        total += sins[i] * weights[i];\n    }\n\n    assert_lt(total, 12);\n}\n",
      "path": "/Users/agatamandrykowska/Ni/conf/src/main.nr"
    }
  }
}
